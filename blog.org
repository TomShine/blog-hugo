#+hugo_base_dir: ~/blog
#+hugo_section: post
#+hugo_weight: auto
#+hugo_auto_set_lastmod: t
#+seq_todo: TODO DRAFT DONE
#+options: author:nil

* Linux
** DRAFT Linux 搭建 APUE 的环境

   我的环境为 Ubuntu 16.04, 具体环境如下：

   #+BEGIN_SRC sh
    $ lsb_release -a
    No LSB modules are available.
    Distributor ID: Ubuntu
    Description: Ubuntu 16.04.4 LTS
    Release: 16.04
    Codename: xenial
   #+END_SRC

*** 1. 下载官网提供的源码
    #+BEGIN_SRC sh
      # 这里下载 v3 的代码
      wget http://www.apuebook.com/src.3e.tar.gz
    #+END_SRC

*** 2. 解压源码

    #+BEGIN_SRC sh
      tar -zxvf src.3e.tar.gz
    #+END_SRC

*** 3. 编译

    #+BEGIN_SRC sh
      cd apue.3e
      make
    #+END_SRC

*** 4. 编译出错

    #+BEGIN_SRC sh
      make
      for i in lib intro sockets advio daemons datafiles db environ fileio filedir ipc1 ipc2 proc pty relation signals standards stdio termios threadctl threads printer exercises; do \
        (cd $i && echo "making $i" && make ) || exit 1; \
      done
      making lib
      make[1]: Entering directory '/home/tomshine/apue.3e/lib'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/lib'
      making intro
      make[1]: Entering directory '/home/tomshine/apue.3e/intro'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/intro'
      making sockets
      make[1]: Entering directory '/home/tomshine/apue.3e/sockets'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/sockets'
      making advio
      make[1]: Entering directory '/home/tomshine/apue.3e/advio'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/advio'
      making daemons
      make[1]: Entering directory '/home/tomshine/apue.3e/daemons'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/daemons'
      making datafiles
      make[1]: Entering directory '/home/tomshine/apue.3e/datafiles'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/datafiles'
      making db
      make[1]: Entering directory '/home/tomshine/apue.3e/db'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/db'
      making environ
      make[1]: Entering directory '/home/tomshine/apue.3e/environ'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/environ'
      making fileio
      make[1]: Entering directory '/home/tomshine/apue.3e/fileio'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/fileio'
      making filedir
      make[1]: Entering directory '/home/tomshine/apue.3e/filedir'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/filedir'
      making ipc1
      make[1]: Entering directory '/home/tomshine/apue.3e/ipc1'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/ipc1'
      making ipc2
      make[1]: Entering directory '/home/tomshine/apue.3e/ipc2'
      for i in open opend open.fe opend.fe; do \
        (cd $i && make ) || exit 1; \
      done
      make[2]: Entering directory '/home/tomshine/apue.3e/ipc2/open'
      make[2]: Nothing to be done for 'all'.
      make[2]: Leaving directory '/home/tomshine/apue.3e/ipc2/open'
      make[2]: Entering directory '/home/tomshine/apue.3e/ipc2/opend'
      make[2]: Nothing to be done for 'all'.
      make[2]: Leaving directory '/home/tomshine/apue.3e/ipc2/opend'
      make[2]: Entering directory '/home/tomshine/apue.3e/ipc2/open.fe'
      make[2]: Nothing to be done for 'all'.
      make[2]: Leaving directory '/home/tomshine/apue.3e/ipc2/open.fe'
      make[2]: Entering directory '/home/tomshine/apue.3e/ipc2/opend.fe'
      make[2]: Nothing to be done for 'all'.
      make[2]: Leaving directory '/home/tomshine/apue.3e/ipc2/opend.fe'
      make[1]: Leaving directory '/home/tomshine/apue.3e/ipc2'
      making proc
      make[1]: Entering directory '/home/tomshine/apue.3e/proc'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/proc'
      making pty
      make[1]: Entering directory '/home/tomshine/apue.3e/pty'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/pty'
      making relation
      make[1]: Entering directory '/home/tomshine/apue.3e/relation'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/relation'
      making signals
      make[1]: Entering directory '/home/tomshine/apue.3e/signals'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/signals'
      making standards
      make[1]: Entering directory '/home/tomshine/apue.3e/standards'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/standards'
      making stdio
      make[1]: Entering directory '/home/tomshine/apue.3e/stdio'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/stdio'
      making termios
      make[1]: Entering directory '/home/tomshine/apue.3e/termios'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/termios'
      making threadctl
      make[1]: Entering directory '/home/tomshine/apue.3e/threadctl'
      make[1]: Nothing to be done for 'all'.
      make[1]: Leaving directory '/home/tomshine/apue.3e/threadctl'
      making threads
      make[1]: Entering directory '/home/tomshine/apue.3e/threads'
      gcc -ansi -I../include -Wall -DLINUX -D_GNU_SOURCE badexit2.c -o badexit2 -L../lib -lapue -pthread -lrt -lbsd
      /usr/bin/ld: cannot find -lbsd
      collect2: error: ld returned 1 exit status
      Makefile:31: recipe for target 'badexit2' failed
      make[1]: *** [badexit2] Error 1
      make[1]: Leaving directory '/home/tomshine/apue.3e/threads'
      Makefile:6: recipe for target 'all' failed
      make: *** [all] Error 1
    #+END_SRC
*** 5. 解决编译错误

    原因是缺少 bsd 库，安装如下：

    #+BEGIN_SRC sh
      sudo apt-get install libbsd-dev
    #+END_SRC

    安装完成后，继续 make 。

*** 6. 复制 apue.h 到 /usr/include 目录下：

    #+BEGIN_SRC sh
      sudo cp ./include/apue.h /usr/include/
    #+END_SRC
*** 7. 复制编译生成的 .a 到系统的 /usr/local/lib 目录下：

    #+BEGIN_SRC sh
      sudo cp ./lib/libapue.a /usr/local/lib/
    #+END_SRC
*** 8. 验证

    #+BEGIN_SRC sh
      $ cd ./apue.3e/intro
      $ gcc hello.c -o hello
      $ ./hello
      hello world from process ID 32488
    #+END_SRC

    成功编译并运行，说明安装成功。

*** 9. 参考资料

    - [[http://www.apuebook.com/apue3e.htmlAdvanced][Programming in the UNIX® Environment 的官方网站]]
     
** DRAFT Linux 搭建 UNP 的环境

   我的环境为 Ubuntu 16.04, 具体环境如下：

   #+BEGIN_SRC sh
    $ lsb_release -a  
    No LSB modules are available.
    Distributor ID:   Ubuntu
    Description:  Ubuntu 16.04.4 LTS
    Release:  16.04
    Codename: xenial
   #+END_SRC

*** 1. 下载

    #+BEGIN_SRC sh
  # 下载官网提供的源码（这里下载 UNPv3 的代码）
  wget http://www.unpbook.com/unpv13e.tar.gz
    #+END_SRC

*** 2. 解压
    #+BEGIN_SRC sh
    # 解压源码
    tar -zxvf unpv13e.tar.gz
    #+END_SRC
*** 3. 生成 makefile

    #+BEGIN_SRC sh
      cd unpv13e
      ./configure
      checking build system type... x86_64-unknown-linux-gnu
      checking host system type... x86_64-unknown-linux-gnu
      checking for gcc... gcc
      checking for C compiler default output... a.out
      checking whether the C compiler works... yes
      checking whether we are cross compiling... no
      checking for suffix of executables... 
      checking for suffix of object files... o
      checking whether we are using the GNU C compiler... yes
      checking whether gcc accepts -g... yes
      checking for gcc option to accept ANSI C... none needed
      checking for ranlib... ranlib
      checking for pthread_create in -lpthread... yes
      checking for t_open in -lnsl... no
      checking for library containing socket... none required
      checking for /usr/local/bind/lib/libbind.a... no
      checking for /home/tomshine/libbind.a... no
      checking for /home/tomshine/libresolv.a... no
      checking for res_init in -lresolv... no
      checking for t_open in -lxti... no
      checking for /home/tomshine/libunp.a... no
      checking for /home/tomshine/libunpxti.a... no
      checking how to run the C preprocessor... gcc -E
      checking for egrep... grep -E
      checking for ANSI C header files... yes
      checking for sys/types.h... yes
      checking for sys/socket.h... yes
      checking for sys/time.h... yes
      checking for time.h... yes
      checking for netinet/in.h... yes
      checking for arpa/inet.h... yes
      checking for errno.h... yes
      checking for fcntl.h... yes
      checking for netdb.h... yes
      checking for signal.h... yes
      checking for stdio.h... yes
      checking for stdlib.h... yes
      checking for string.h... yes
      checking for sys/stat.h... yes
      checking for sys/uio.h... yes
      checking for unistd.h... yes
      checking for sys/wait.h... yes
      checking for sys/un.h... yes
      checking for sys/param.h... yes
      checking for sys/select.h... yes
      checking for sys/sysctl.h... yes
      checking for poll.h... yes
      checking for sys/event.h... no
      checking for strings.h... yes
      checking for sys/ioctl.h... yes
      checking for sys/filio.h... no
      checking for sys/sockio.h... no
      checking for pthread.h... yes
      checking for net/if_dl.h... no
      checking for xti.h... no
      checking for xti_inet.h... no
      checking for netconfig.h... no
      checking for netdir.h... no
      checking for stropts.h... yes
      checking whether time.h and sys/time.h may both be included... yes
      checking if uint8_t defined... yes
      checking if int16_t defined... yes
      checking if uint16_t defined... yes
      checking if int32_t defined... yes
      checking if uint32_t defined... yes
      checking if size_t defined... yes
      checking if ssize_t defined... yes
      checking if socklen_t defined... yes
      checking if sa_family_t defined... yes
      checking if t_scalar_t defined... yes
      checking if t_uscalar_t defined... yes
      checking for struct sockaddr.sa_len... no
      checking for struct sockaddr_storage... yes
      checking for struct sockaddr_storage.ss_family... yes
      checking for struct msghdr.msg_control... yes
      checking for struct ifreq.ifr_mtu... yes
      checking for getaddrinfo function prototype in netdb.h... yes
      checking for getnameinfo function prototype in netdb.h... yes
      checking for gethostname function prototype in unistd.h... yes
      checking for getrusage function prototype in sys/resource.h... yes
      checking for hstrerror function prototype in netdb.h... yes
      checking for if_nametoindex function prototype in net/if.h... yes
      checking for inet_aton function prototype in arpa/inet.h... yes
      checking for inet_pton function prototype in arpa/inet.h... yes
      checking for pselect function prototype in sys/select.h... yes
      checking for snprintf function prototype in stdio.h... yes
      checking for sockatmark function prototype in sys/socket.h... yes
      checking for struct addrinfo... yes
      checking for struct if_nameindex... yes
      checking for struct sockaddr_dl... no
      checking for struct timespec... yes
      checking for /dev/tcp... no
      checking for /dev/xti/tcp... no
      checking for /dev/streams/xtiso/tcp... no
      checking for bzero... yes
      checking for getaddrinfo... yes
      checking for gethostname... yes
      checking for gethostbyname2... yes
      checking for gethostbyname_r... yes
      checking for getnameinfo... yes
      checking for hstrerror... yes
      checking for if_nametoindex... yes
      checking for inet_aton... yes
      checking for inet_pton... yes
      checking for inet6_rth_init... yes
      checking for kqueue... no
      checking for kevent... no
      checking for mkstemp... yes
      checking for poll... yes
      checking for pselect... yes
      checking for snprintf... yes
      checking for sockatmark... yes
      checking for vsnprintf... yes
      checking for IPv4 support... yes
      checking for IPv6 support... yes
      checking for Unix domain sockets... yes
      checking for multicast support... yes
      checking for -I/home/tomshine/doc/unp2ev1/src/include... no
      configure: creating ./config.status
      config.status: creating Makefile
      config.status: creating Make.defines
      config.status: creating config.h
    #+END_SRC

*** 4. 编译

    #+BEGIN_SRC sh
      cd ./lib
      make
    #+END_SRC

    生成的 libunp.a 在上一级目录 npv13e 下。

*** 5. 复制 unp.h 和 config.h 到 /usr/include 目录下：

    #+BEGIN_SRC sh
      sudo cp lib/unp.h /usr/include  
      sudo cp config.h /usr/include 
    #+END_SRC
*** 6. 复制编译生成的 .a 到系统的 /usr/local/lib 目录下：

    #+BEGIN_SRC sh
      sudo cp ./lib/libunp.a /usr/local/lib/ 
    #+END_SRC

*** 7. 验证

    #+BEGIN_SRC sh
      $ cd ./unpv13e/intro
      $ gcc byteorder.c -o byteorder
      $ ./hello
      $ ./byteorder 
      x86_64-unknown-linux-gnu: little-endian
    #+END_SRC

    成功编译并运行，说明安装成功。

*** 8. 参考资料

    - [[http://www.unpbook.com/UNIX][Network Programming 的官方网站]]
     
** DRAFT Linux 生成动态库和静态库

*** 1、静态库

    Linux 上的静态库为 *.a 文件，本质上一个归档文件, 生成一个静态库的步骤如下：

    1. 通过源文件生成目标文件(*.o)
    2. 使用命令 ar 归档目标文件，生成静态库
    3. 配置静态库，写一个静态库中函数的头文件

    使用静态库的时候把头文件包含进入，并且需要链接库。

**** 1.1、写源文件，并生成目标文件

     mymath.c 源码如下：

     #+BEGIN_SRC c
      int my_add(int a, int b) {
          return a + b;
      }

      int my_sub(int a, int b) {
          return a - b;
      }

      myprint.c 源码如下：

      #include <stdio.h>

      void my_count(const char * message) {
          fprintf(stdout, "%s\n", message);
      }
     #+END_SRC

     为这两个源文件生成目标:

     #+BEGIN_SRC sh
      # 生成目标文件
      $ gcc -c mymath.c
      $ gcc -c myprint.c
     #+END_SRC

**** 1.2、归档目标文件，得到静态库

     #+BEGIN_SRC sh
      $ ar crv mylib.a mymath.o myprint.o
      a - mymath.o
      a - myprint.o
     #+END_SRC

     这样就得到了静态库 mylib.a。

     =ar= 命令的参数介绍：

     1. =c= 如果需要生成新的库文件，不要警告
     2. =r= 替代库中现有的文件或者插入新文件
     3. =v= 输出详细信息

     注意：使用 ar 生成的静态必须是 libxxx.a 格式命名，因为这是 Linux 规定。我们链接库的时候就可以使用 -lxxx。当我们使用 -lxxx 的时候，编译器就会在指定的目录搜索 libxxx.a 或 libxxx.so。

     使用 =ar t= 查询静态库包含的目标：

     #+BEGIN_SRC sh
      $ ar t libmylib.a
      myprint.o
      mymath.o
     #+END_SRC

**** 1.3、生成对应的头文件

     mylib.h 源码如下：

     #+BEGIN_SRC c
      #ifndef __MY_LIB_H__
      #define __MY_LIB_H__

      int my_add(int a, int b);
      int my_sub(int a, int b);

      void my_cout(const char *);

      #endif
     #+END_SRC

**** 1.4、测试静态库

     在当前目录下新建 test.c 文件，内容如下：

     #+BEGIN_SRC c
      #include "mylib.h"

      int main() {
          int a = my_add(1, 2);
          printf("my_add(1,2)=%d\n", a);

          int b = my_sub(2, 2);
          printf("my_sub(2,2)=%d\n", b);

          my_count("1231321");

          return 0;
      }
     #+END_SRC

     编译 test.c

     #+BEGIN_SRC sh
      $ gcc main.c -L./lib -lmylib
     #+END_SRC

     - =-L= 参数告诉链接器哭的目录
     - =-l= 参数告诉链接器链接 libmylib.a 的库

     运行 a.out

     #+BEGIN_SRC sh
      $ ./a.out
      my_add(1,2)=3
      my_sub(2,2)=0
      1231321
     #+END_SRC

**** 1.5、使用 Makefile 简化过程

     #+BEGIN_SRC makefile
      .PHONY: build test

      build: libmylib.a

      libmylib.a: mymath.o myprint.o
          ar crv $@ mymath.o myprint.o

      my_math.o: mymath.c
          gcc -c mymath.c

      my_print.o: myprint.c
          gcc -c myprint.c

      test: a.out

      a.out: test.c
          gcc test.c -L. -lmylib

      clean:
          rm *.o *.a
     #+END_SRC

     这个就不解释了。

*** 2、动态库

    Linux 下动态的格式为 libxxx.so，其中 so 是 Shared Obeject 的缩写，即目标是共享文件, 生成一个动态库步骤如下：

    1. 通过源文件生成目标文件(*.o)
    2. 使用命令 gcc 把目标文件生成共享库
    3. 通过 -L<path> -lxxx 的 gcc 的 flag 指定链接生成共享库。
    4. 把生成的库放到链接库的标准路径后或者设置 LD_LIBRARY_PATH，才能正确的链接动态。

    源文件和静态库的一样，只是生成库的方法变了：

    #+BEGIN_SRC sh
    $ gcc -c -fPIC mymath.c
    $ gcc -c -fPIC myprint.c
    $ gcc -shared -o libmylib.so mymath.o myprint.o
    #+END_SRC

    实际上上述过程分为编译和链接两步

    - =-fPI= C是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性；
    - =-shared= 是链接选项，告诉gcc生成动态库而不是可执行文件。

    编译 test.c 并运行 a.out:

    #+BEGIN_SRC sh
      $ gcc main.c -L./ -lmylib                   
      main.c: In function ‘main’:
      main.c:5:5: warning: incompatible implicit declaration of built-in function ‘printf’ [enabled by default]
          printf("my_add(1,2)=%d\n", a);
          ^
      $ ./a.out
      ./a.out: error while loading shared libraries: libmylib.so: cannot open shared object file: No such file or directory
    #+END_SRC

    可以看到报错了，找不到 libmylib.so，原来Linux是通过 /etc/ld.so.cache 文件搜寻要链接的动态库的。而 /etc/ld.so.cache 是 ldconfig 程序读取 /etc/ld.so.conf 文件生成的。（注意， /etc/ld.so.conf 中并不必包含 /lib 和 /usr/lib，ldconfig程序会自动搜索这两个目录）如果我们把 libmylib.so 所在的路径添加到 /etc/ld.so.conf 中，再以root权限运行 ldconfig 程序，更新 /etc/ld.so.cache ，a.out运行时，就可以找到 libmylib.so。

    但作为一个简单的测试例子，让我们改动系统的东西，似乎不太合适。还有另一种简单的方法，就是为a.out指定 LD_LIBRARY_PATH。LD_LIBRARY_PATH=. ./a.out 程序就能正常运行了。LD_LIBRARY_PATH=. 是告诉 a.out，先在当前路径寻找链接的动态库。

    对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH 段, 环境变量
    =LD_LIBRARY_PATH= ,  =/etc/ld.so.cache= 文件列表,  =/lib/= , =/usr/lib= 目录, 找到库文件后将其载入内存. (http://blog.chinaunix.net/uid-23592843-id-223539.html)

    使用 Makefile 简化：

    #+BEGIN_SRC makefile
      .PHONY: build test clean

      build: libmylib.so

      libmylib.so: mymath.o myprint.o
          gcc -o $@ -shared $<

      mymath.o: mymath.c
          gcc -c -fPIC $<

      myprint.o: myprint.c
          gcc -c -fPIC $<

      test: a.out

      exec: test.c libmylib.so
          gcc test.c -L. -lmylib
          LD_LIBRARY_PATH=. ./a.out

      clean:
          rm -f *.o *.so a.out
    #+END_SRC

    makefile 有问题，需要修改。

** DRAFT 编写自己第一个 Linux 内核模块

   https://app.yinxiang.com/shard/s18/nl/19217884/736939a5-dc4e-4ae2-a7b1-5f40a7032981/

   内核模块是 Linux 内核向外部提供的一个插口，其全称为动态可加载内核模块（Loadable Kernel Module，LKM），我们简称为模块。

   Linux 内核之所以提供模块机制，是因为它本身是一个单内核（monolithic kernel）。单内核的最大优点是效率高，因为所有的内容都集成在一起，但其缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。

*** 1、什么是模块

    模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不同的。模块通常由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序或其他内核上层的功能。

    为了加深对内核模块的了解，给出应用程序与内核模块程序的比较:

    | 功能     | C语言应用程序       | 内核模块程序                                |
    |----------+---------------------+---------------------------------------------|
    | 使用函数 | glibc 库            | 内核函数                                    |
    | 头文件   | =/usr/include=      | =/usr/src/linux-headers-uname -r /include/= |
    | 运行空间 | 用户空间(user mode) | 内核空间(kernel mode)                       |
    | 运行权限 | 普通用户            | 超级用户                                    |
    | 入口函数 | =main()=            | =module_init()/init_moudle()=               |
    | 出口函数 | =exit()=            | =module_exit()/cleanup_module()=            |
    | 编译     | =gcc –c=            | =Makefile=                                  |
    | 连接     | =gcc=               | =insmod=                                    |
    | 运行     | 直接运行            | =insmod=                                    |
    | 调试     | =gdb=               | =kdbug= 、 =kdb= 、 =kgdb= 等               |

    从表我们可以看出，内核模块程序不能调用 glibc 库中的函数，它运行在内核空间，且只有超级用户可以对其运行。另外，模块程序必须通过 module_init() 和 module-exit() 函数来告诉内核“我来了”和“我走了”。

*** 2、编写一个简单的模块

    模块和内核都在内核空间运行，模块编程在一定意义上说就是内核编程。因为内核版本的每次变化，其中的某些函数名也会相应地发生变化，因此模块编程与内核版本密切相关。

    运行的环境下如下：

    - 系统：CentOS 7
    - 内核版本：3.10

**** 2.1、程序举例

     #+BEGIN_SRC c
 #include<linux/module.h>
 #include<linux/kernel.h>
 #include<linux/init.h>

 static int __init hello_init(void)
 {
     printk(KERN_INFO "Hello Kernel Module!\n");
     return 0;
 }

 static void __exit hello_cleanup(void)
 {
     printk(KERN_INFO "Bye Kernel Module!\n");
 }

 module_init(hello_init);
 module_exit(hello_cleanup);

 MODULE_AUTHOR("Noah");
 MODULE_DESCRIPTION("hello");
 MODULE_LICENSE("GPL");
     #+END_SRC

     说明:

     - 头文件 linux/module.h 所有模块都要使用此文件
     - 头文件 linux/kernel.h 包含了常用的内核函数
     - 头文件 linux/init.h 包含了宏 __init 和 __exit，它们允许释放内核占用的内存
     - hello_init 函数是模块的初始化函数，它必需包含诸如要编译的代码、初始化数据结构等内容
     - hello_cleanup 是模块的退出和清理函数，此处可以做所有终止该驱动程序时相关的清理工作
     - module_init 和 module_exit 是模块编程中最基本也是必须的两个函数。module_init 是驱动程序初始化的入口点，而 module_exit 注销由模块提供的所有功能。
     - 使用了 printk 函数，该函数是由内核定义的，功能与C库中的 printf 类似，它把要打印的信息输出到终端或系统日志。

***** 2.1、编写Makefile 文件

      #+BEGIN_SRC makefile
 obj-m := hello.o

 KDIR :=/lib/modules/$(shell uname -r)/build

 all:
     make -C $(KDIR) M=$(shell pwd) modules
 clean:
     make -C $(KDIR) M=$(shell pwd) clean
      #+END_SRC

      - =KDIR :=/lib/modules/$(shell uname -r)/build= 是编译内核模块需要的 Makefile 的路径，CentOS 下是 =/lib/modules/2.6.31-14-generic/build=
      - =make -C $(KDIR) M=$(shell pwd) modules= 编译内核模块。－C 将工作目录转到 KDIR，调用该目录下的 Makefile，并向这个Makefile传递参数M的值是 =$(shell pwd) modules=

      具体选项说明如下:

      #+BEGIN_SRC sh

 make -C $KDIR M=$PWD [target]
 -C $KDIR
    The directory where the kernel source is located.
    "make" will actually change to the specified directory
    when executing and will change back when finished.
 M=$PWD
    Informs kbuild that an external module is being built.
    The value given to "M" is the absolute path of the
    directory where the external module (kbuild file) is
    located.
 target
    modules
        The default target for external modules. It has the
        same functionality as if no target was specified. See
        description above. 默认是modules，可不写。
    modules_install
        Install the external module(s). The default location is
        /lib/modules/<kernel_release>/extra/, but a prefix may
        be added with INSTALL_MOD_PATH.
    clean
        Remove all generated files in the module directory only.
    help
        List the available targets for external modules.
      #+END_SRC

      参考[[https://www.kernel.org/doc/Documentation/kbuild/modules.txt][kernel module doc]]

**** 2.3、编译模块

     #+BEGIN_SRC sh
 make       # 在 hello.c 所在文件夹就会有 hello.ko ，这个就是我们需要的内核模块
 make clean # 清理编译垃圾，hello.ko 也会清理掉
     #+END_SRC

**** 2.4、加载模块

     #+BEGIN_SRC 
 sudo insmod hello.ko # 注意必须是root权限
 dmesg
     #+END_SRC

     我们用 dmesg 就可以看到 产生的内核信息啦: "Hello Kernel Module!"
     如果没有输出，因为如果你在字符终端而不是终端模拟器下运行的话，就会输出，因为在终端模拟器下时会把内核消息输出到日志文件/var/log/kern.log中。

**** 2.5、 卸载模块

     #+BEGIN_SRC sh
 rmmod hello
     #+END_SRC

     再用 =dmesg= 可以看到 =Bye Kernel Module!=

*** 3、管理内核模块的工具

    =modutils= 是管理内核模块的一个软件包。可以在任何获得内核源代码的地方获取 Modutils(modutils-x.y.z.tar.gz)源代码，然后选择最高级别的 patch.x.y.z 等于或小于当前的内核版本，安装后在 /sbin 目录下就会有 insmod、rmmod、ksyms、lsmod、modprobe 等实用程序。当然，通常我们在加载 Linux 内核时，modutils 已经被载入。

**** 3.1、insmod

     装在内核模块，调用 insmod 程序把需要插入的模块以目标代码的形式插入到内核中。在插入的时候，insmod 自动调用 init_module() 函数运行。注意，只有超级用户才能使用这个命令，其命令格式为：insmod [path] modulename.ko

**** 3.2、rmmod

     #+BEGIN_EXAMPLE
     卸载内核模块
     #+END_EXAMPLE

     调用 rmmod 程序将已经插入内核的模块从内核中移出，rmmod 会自动运行 cleanup_module()  函数，其命令格式为：

     #+BEGIN_SRC sh
     rmmod [path] modulename.ko
     #+END_SRC

**** 3.3、lsmode

     调用 lsmod 程序将显示当前系统中正在使用的模块信息。实际上这个程序的功能就是读取 proc 文件系统中的文件 /proc/modules 中的信息，其命令格式为：

     #+BEGIN_SRC sh
     lsmod
     #+END_SRC

**** 3.4、ksyms 命令

     =ksyms= 这个程序用来显示内核符号和模块符号表的信息。与 lsmod 相似，它的功能是读取 /proc文件系统中的另一个文件 /proc/kallsyms 。其命令格式为：

     #+BEGIN_SRC sh
      ksyms
     #+END_SRC

**** 3.5、其他

     1. =dmesg= 查看输出信息 =cat /var/log/syslog=
     2. =strace= 跟踪系统调用

*** 4、Trouble Shooting

    #+BEGIN_SRC sh
      insmod: ERROR: could not insert module module.ko: Invalid parameters
    #+END_SRC

    出现这个问题，一般都是 Linux 头文件目录和当系统运行的版本不匹配。使用命令：uname -r 查看当前运行的内核版本，然后选择正确的 Linux头文件路径，也可以下载和机器内核对应的Linux源码，这样指定Linux头文件目录到指定的源码目录就行了。第二个就是生成的模块名字不能以module命名，改成其他名字就好了。

    这个问题出现在另外一个地方，我在 MacOS 写的代码，然后挂在目录在 Linux 上，然后编译加载就会出现这个问题，如果直接在 Linux 上则没有问题，至今没有解决。

    另外模块的printk打印的信息不能直接显示在终端上，可以使用 dmesg 查看自开机以来的信息就可以看到printk输出的信息了，使用 dmesg | tail1 可以查看最后的几个消息。使用 rmmod 可以移除安装了的模块。

    #+BEGIN_SRC 
      insmod: ERROR: could not insert module hello.ko: Invalid module format
    #+END_SRC

    TODO…

*** 5、参考文章：
    - http://stackoverflow.com/questions/21244481/error-using-insmod-could-not-insert-module-hello-world-ko-invalid-module-forma
    - http://blog.csdn.net/u013095333/article/details/52457717

* macOS
** DRAFT macOS 搭建 MASM 的汇编环境                                :macOS:OS:

   https://app.yinxiang.com/shard/s18/nl/19217884/5d2e04c6-f98b-453a-a9d8-07ec1c6708bf/

*** 安装 nasm

    #+BEGIN_SRC sh
    # install
    $ brew install nasm

    # 查询版本
    $ nasm -v
    NASM version 0.98.40 (Apple Computer, Inc. build 11) compiled on Feb 13 2018
    #+END_SRC

*** 实例

    写一个汇编的 hello world, 文件名为 hello.asm:

    #+BEGIN_SRC nasm
    global start

    section .text
    start:
        push    dword msg.len
        push    dword msg
        push    dword 1
        mov     eax, 4
        sub     esp, 4
        int     0x80
        add     esp, 16

        push    dword 0
        mov     eax, 1
        sub     esp, 12
        int     0x80

    section .data

    msg:    db      "hello world", 10
    .len:   equ     $ - msg
    #+END_SRC

*** 安装 Command Line Tools

    如果已经安装了 Xcode 就不需要执行这条命令了。

    #+BEGIN_SRC sh
    sudo xcode-select --install
    #+END_SRC

*** 编译/链接/运行

    注意: mac 上面的 gcc 编译 .o 文件的时候默认的入口是 _main ，而使用 ld 命令时，默认的是 start 。

    分步执行:
    1. 编译: =nasm -o hello.o -f macho hello.asm=
    2. 连接: =ld -arch i386 -macosx_version_min 10.7.0 -no_pie -e_main -o hello hello.o=
 
**** nasm

     - =-o hello.o= : 输入文件
     - =-f macho= : 指定文件格式
       - =Linux= : elf 或 elf64
       - =macOS= : macho

**** ld

     - =-arch i386= : 指定为架构(32位)
     - =-macosx_version_min 10.6= : macOS - complains about default specification
     - =-no_pie= : macOS, 删除 ld 的 warning
     - =-e main= : 指定 main symbol name (macOS - 默认是 start
     - =-o hello= : 输入文件

** DRAFT macOS 的目录结构                                          :macOS:OS:

   =Mac= 机器主板使用了 =Intel= 主导的 =EFI= 标准，硬盘分区格式采用 =GPT=。这种 =EFI+GPT= 的方式相比传统的 =BIOS＋MBR= 的方式有很多好处。

*** 硬盘分区

    默认情况下，=macOS= 把硬盘分成了3个 =GPT= 分区。

    1. 第一个分区：就是 GPT 标准要求的 ESP 分区，这个分区很小，200MB，FAT 文件系统格式。按照 EFI 惯例，应该用来存放操作系统的引导程序。但是苹果没有遵守这个惯例，它的引导程序 =boot.efi= 并没有存放在 ESP 中，这个分区只是被苹果用来存放升级固件的文件。
    2. 第二个分区：就是*macOS 的系统分区*，它占用了大部分磁盘空间，用来存放整个 =macOS= 系统和用户数据，分区文件系统格式为 =HFS+=。

    - 第三个分区：是*系统恢复分区*，里面存放了一个精简的 =macOS= 系统，用来完成系统恢复、安装等任务，类似于 =WindowsPE=。默认情况下，=macOS= 自带的磁盘工具并不能显示 ESP 分区和恢复分区，需要开启 DEBUG 菜单才可以。开启方法为：=defaults write com.apple.DiskUtility DUDebugMenuEnabled 1=

*** macOS 系统分区的目录结构

    =macOS= 有着很深的 =Unix= 血统，所以其目录结构基本符合 Unix 系统目录结构。但是有很多目录在Finder 中并看不到，这是因为这些目录的被设置了隐藏属性，我们可以在终端窗口中利用 Unix 命令查看。

*** 符合 Unix 传统的目录

    - =/=: 根目录(root, the Local Domain)
    - =/bin=: 传统 =Unix= 命令的存放目录
    - =/sbin=: 传统 =Unix= 管理类命令存放目录，只有 =root= 才能使用的命令
    - =/usr=: 第三方程序安装目录，=/usr/bin=, =/usr/sbin=, =/usr/lib=，其中 =/usr/lib= 目录中存放了共享库（动态链接库）
    - =/etc=: 标准 Unix 系统配置文件存放目录，如用户密码文件 j=/etc/passwd=。此目录实际为指向 =/private/etc= 的链接。
    - =/dev=: 设备文件存放目录
    - =/tmp=: 临时文件存放目录，其权限为所有人任意读写。此目录实际为指向 =/private/tmp= 的链接。
    - =/var=: 存放经常变化的文件，如日志文件。此目录实际为指向 =/private/var= 的链接。

*** macOS 特有的目录

    =macOS= 系统中，除了标准的 =Unix= 目录外，还增加了特有的目录。

    - =/Applications=: 应用程序目录，默认所有的 =GUI= 应用程序都安装在这里(GUI Application)
    - =/Applications/Utilities=: =GUI= 应用程序工具集(GUI utilities)
    - =/Developer=: =Xcode= 开发这工具（Xcode developer tools)
    - =/Library=: 系统的数据文件、帮助文件、文档等等（User installed frameworks)
    - =/Network=: 网络节点存放目录(the Network domian)
    - =/System=: 只包含一个名为 =Library= 的目录，这个子目录中存放了系统的绝大部分组件，如各种=framework=，以及内核模块，字体文件等等
    - =/Users=: 存放用户的个人资料和配置。每个用户有自己的单独目录(Home directories, the User domain)
    - =~/Desktop=: 用户的桌面(Your desktop)
    - =~/Document=: 用户的文档目录(Your documents)
    - =~/Movies=: 用户的电影目录(Your movies directory: iMovie uses it by default)
    - =~/Music=: 用户的音乐目录(Your music directory: iTunes uses it by default)
    - =~/Pictures=: 用户的图片目录(Your picture directory: iPhoto uses it by default)
    - =~/Public=: 用户共享目录(For sharing: contents visible to others)
    - =~/Sites=: 用户搭建网站的目录(Your www(apache) diectory)
    - =/Volumes=: 文件系统挂载点存放目录，例如U盘
    - =/cores=: 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。
    - =/private=: 里面的子目录存放了=/tmp=, =/var=, =/etc=等链接目录的目标目录
** DRAFT macOS 的 luanchctl
* FreeeBSD

  TODO...

* Windows

  TODO...

* Compile and link
** DRAFT GCC 和 Clang 命令                                  :gcc:clang:@编译:

   主要介绍 编译工具 Gcc 和 Clang 的常用选项。

   <!--more-->

*** Linux 下 使用 Gcc

    - [GCC 编译选项分析](http://www.cnblogs.com/showna/articles/1013401.html)
    - [GCC Command-Line Options](http://tigcc.ticalc.org/doc/comopts.html)
*** macOS 下 使用 Clang

    https://app.yinxiang.com/shard/s18/nl/19217884/730115d2-9ddf-4cb4-bd98-9fe716b3e523/
** DRAFT GDB 和 LLDB 命令总结                                :gdb:lldb:@编译:
   :PROPERTIES:
   :EXPORT_FILE_NAME: gdb-and-lldb-usage
   :EXPORT_DATE: <2018-10-16 Tue>
   :END:

   主要介调试工具 =gdb= 和 ==lldb= 的常用选项。

   <!--more-->

*** Linux 的 GDB 调试
**** 1. 运行 GDB

     启动 GDB 的方法有以下几种：

     - =gdb <program>= ：program 是用户的执行文件，一般在当然目录下。例如： =gdb hello=
     - =gdb <program> core= ：用 GDB 同时调试一个运行程序和 core 文件，core 是程序非法执行后 core dump 后产生的文件。例如： =gdb hello –c core.xxxxx= ,其中xxxxx为进程的pid
     - =gdb <program> <PID>= ： 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。GDB 会自动 =attach= 上去，并调试他。program 应该在 PATH 环境变量中搜索得到。 例如： =gdb –p 10000=

**** 2. 运行命令

     | 命令        | 功能                                                   |
     |-------------+--------------------------------------------------------|
     | =run param= | 运行程序或重新运行程序，可以带参数，相当于命令行参数。 |
     | =Ctrl+C=    | 程序暂停，可以操作gdb的命令。                          |
     | =continue=  | 继续运行                                               |
     | =quit=      | 退出gdb                                                |

**** 3. 设置断点

     | 命令                         | 功能                                                                                                                           |
     |------------------------------+--------------------------------------------------------------------------------------------------------------------------------|
     | =break <function>=           | 在进入指定函数时停住。                                                                                                         |
     | =break <linenum>=            | 在指定行号停住。                                                                                                               |
     | =break +/-offset=            | 在当前行号的前面或后面的offset行停住。offiset为自然数。                                                                        |
     | =break filename:linenum=     | 在源文件filename的linenum行处停住。                                                                                            |
     | =break filename:function=    | 在源文件filename的function函数的入口处停住。                                                                                   |
     | =break *address=             | 在程序运行的内存地址处停住。                                                                                                   |
     | =break=                      | break命令没有参数时，表示在下一条指令处停住。                                                                                  |
     | =break ... if <condition>=   | ...是文件名行号等参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设置break if i=100，表示当i为100时停住程序。 |
     | =info break/breakpoints [n]= | 查看断点时，可使用info命令。n表示断点号                                                                                        |
     
**** 4. 设置观察点

     | 命令               | 功能                                                                     |
     |--------------------+--------------------------------------------------------------------------|
     | =watch <expr>=     | 为表达式（变量）expr设置一个观察点。一旦表达式值有变化时，马上停住程序。 |
     | =rwatch <expr>=    | 当表达式（变量）expr被读时，停住程序。                                   |
     | =awatch <expr>=    | 当表达式（变量）的值被读或被写时，停住程序。                             |
     | =info watchpoints= | 列出当前所设置了的所有观察点。                                           |

**** 5. 断点维护命令

     | 命令                                   | 功能                                                                                                                                                                            |
     |----------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     | clear                                  | 清除所有的已定义的停止点。                                                                                                                                                      |
     | clear <function>                       | 清除所有的已定义的停止点。                                                                                                                                                      |
     | clear <filename:function>              | 清除所有的已定义的停止点。                                                                                                                                                      |
     | clear <linenum>                        | 清除所有的已定义的停止点。                                                                                                                                                      |
     | clear <filename:linenum>               | 清除所有的已定义的停止点。                                                                                                                                                      |
     | delete [breakpoints] [range...]        | 删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。                                                 |
     | disable [breakpoints] [range...]       | disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis。                                                                        |
     | 1.enable [breakpoints] [range...]      | 1.enable所指定的停止点，breakpoints为停止点号。                                                                                                                                 |
     | 2.enable [breakpoints] once range...   | 2.enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。                                                                                                        |
     | 3.enable [breakpoints] delete range... | 3.enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。                                                                                                           |
     | continue [ignore-count]                | 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。                                                     |
     | c [ignore-count]                       | 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。                                                     |
     | fg [ignore-count]                      | 恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。                                                     |
     | step <count>                           | 单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。 |
     | next <count>                           | 同样单步跟踪，如果有函数调用，他不会进入该函数。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。                                      |
     | set step-mode                          | 打开/关闭step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。                                                                 |
     | set step-mode on                       | 打开/关闭step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。                                                                 |
     | set step-mod off                       | 打开/关闭step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。                                                                 |
     | finish                                 | 运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。                                                                                              |
     | until 或 u                             | 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。                                                                                                        |
     | stepi 或 si                            | 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。                                                                                  |
     | nexti 或 ni                            | 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。                                                                                  |
     为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。 

     #+BEGIN_SRC 
commands [bnum]
 ... command-list ...
end
     #+END_SRC  

**** 6. 搜集任务信息

     | 命令                               | 功能                                                                                                             |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------|
     | =backtrace/bt  <+-n>=              | 打印当前的函数调用栈的所有信息。                                                                                 |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------|
     | =frame/f <n>= / =select-frame <n>= | 切换当前栈，无参数会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。 |
     | =up/up-silently <n>=               | 表示向栈的上面移动n层，可以不打n，表示向上移动一层。                                                             |
     | =down/down-silently <n>=           | 表示向栈的下面移动n层，可以不打n，表示向下移动一层。                                                             |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------|
     | =info frame/f=                     | 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。                                   |
     | =info args=                        | 打印出当前函数的参数名及其值。                                                                                   |
     | =info locals=                      | 打印出当前函数中所有局部变量及其值。                                                                             |
     | =info catch=                       | 打印出当前的函数中的异常处理信息。                                                                               |
     | =info line linespec=               | 打印行 linespec源码编译出的代码的起始和结束地址。                                                                |
     | =info register=                    | 打印出除浮点数之外的所有寄存器的名称和值。                                                                       |
     | =info all-registers=               | 查看所有寄存器的情况（包括浮点寄存器）。                                                                         |
     | =info registers regname=           | 查看所指定的寄存器的情况。                                                                                       |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------|
     | =set listsize <count>=             | set命令设置一次显示源代码的行数。                                                                                |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------|
     | =list <linenum>=                   | 显示程序第linenum行的周围的源程序。                                                                              |
     | =list <first>, <last>=             | 显示从first行到last行之间的源代码。                                                                              |
     | =list , <last>=                    |                                                                                                                  |
     | =list <function>=                  | 显示函数 funciont 的源代码                                                                                       |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------|
     | =forward-search <regexp>=          | 搜索源代码。                                                                                                     |
     | =search <regexp>=                  | 搜索源代码。                                                                                                     |
     | =reverse-search <regexp>p=         | 搜索源代码。                                                                                                     |
     | =directory <dirname ... >=         | 指定源文件的路径。                                                                                               |
     | =dir <dirname ... >=               | 指定源文件的路径。                                                                                               |
     | =show directories=                 | 指定源文件的路径。                                                                                               |
     |------------------------------------+------------------------------------------------------------------------------------------------------------------|
     | =call <expr>=                      | 表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。       |
     | =return= / =return <expression>=   | 使用return命令取消当前函数的执行，并立即返回，如果指定了<expression>，那么该表达式的值会被认作函数的返回值。     |

**** 7. 其它命令

     | 命令                              | 功能                                                                                                   |
     |-----------------------------------+--------------------------------------------------------------------------------------------------------|
     | disassemble                       | 把某范围内存内容反编译为机器指令。缺省情况下，内存范围是选定帧的程序计数器周围的函数。                 |
     |                                   | 只一个参数时，参数值为程序计数器的值；两个参数则是指定地址范围。                                       |
     |-----------------------------------+--------------------------------------------------------------------------------------------------------|
     | =print exp=                       | 查看变量的值。                                                                                         |
     |-----------------------------------+--------------------------------------------------------------------------------------------------------|
     | =print /f exp=                    |                                                                                                        |
     | =print var@ len=                  |                                                                                                        |
     | =print file::variable=            | - exp是表达式，/f指定打印时的格式。                                                                    |
     | =print function::variable=        | - exp是C语言形式的表达式，功能很强大，如可以查看变量地址&var。                                         |
     | =set/show print address=          | - exp表达式为C格式的赋值语句，这样就可以完成变量的赋值。                                               |
     | =set/show print array=            | - print只能查看变量在内存中的表示，不能查看绝对地址的内存值，var是变量表达式，len查看表达式的个数 。   |
     | =set/show print elements/=        |                                                                                                        |
     | =null-stop/pretty/union/=         |                                                                                                        |
     | =object/static-members/=          |                                                                                                        |
     | =vtbl <on/off>=                   |                                                                                                        |
     |-----------------------------------+--------------------------------------------------------------------------------------------------------|
     | =::=                              | 指定一个在文件或是一个函数中的变量                                                                     |
     |-----------------------------------+--------------------------------------------------------------------------------------------------------|
     | =x/nfu addr=, 常用 =：x /64 addr= | 使用x命令可以按格式查看绝对地址的内存信息，内存信息按NFU格式打印到控制台。                             |
     |                                   | nfu 是格式表达式:                                                                                      |
     |                                   | n：查看内存的个数                                                                                      |
     |                                   | f：显示格式，显示格式可以是i（10进制），x（16进制）。                                                  |
     |                                   | u：按什么数据类型显示：                                                                                |
     |                                   | u：可以是下面几种类型：                                                                                |
     |                                   | b：1字节显示（Bytes）。                                                                                |
     |                                   | h：2字节显示（Halfwords）。                                                                            |
     |                                   | w：4字节显示（Words），默认显示类型为4字节显示。                                                       |
     |                                   | g：8字节显示（Giant words）。                                                                          |
     | =display/<fmt> <expr>=            | expr是一个表达式，fmt表示显示的格式，addr表示内存地址                                                  |
     | =display/<fmt> <addr>=            | 当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。 |
     | =undisplay <dnums...>=            |                                                                                                        |
     | =disable/enable/delete=           |                                                                                                        |
     | =display <dnums...>=              |                                                                                                        |
     | =info display=                    |                                                                                                        |
     | how convenience                   | 该命令查看当前所设置的所有的环境变量，环境变量可以通过set命令设置。                                    |

**** 8. 总结

     - 查看源代码： =list= or =l=
     - 断点操作类:
       - 符号名设置断点： =break main= 或 =b main=
       - 查看所有断点： =info breakpoints= 或 =info b=
       - 根据编号删除断点： =delete 1=
       - 删除所有断点： =delete= 或 =d=
     - 查看寄存器类： =info register= 或 =info r=
     - 查看值类：
       - 查看函数的反汇编代码： =disas=
       - 列出所有的局部变量： =info locals=
       - 列出所有参数： =info args=
       - 运行期进程的内存映射： =info proc mappings=
       - 查看地址： =p/x $rbp= (查看一个特定的寄存器)
       - 查看地址的值：
         - =x/1xg $rsp= (查看地址的值是否符合预期)
         - =x/1xg $rsp+0x18= (根据 寄存器+偏移量寻址)
       - 查看调用栈帧： =bt= 或 =backtrace=
       - 查看符号地址： =info address main.main=
       - 根据符号地址反向查看符号详情： =info symbol 0x401180=
     - 单步机器指令
       - =si= 单步进入
       - =ni= 单步执行 next
       - =ret= 单步返回

     - 线程调试：

       https://blog.csdn.net/Jin_Kwok/article/details/80104022

** DRAFT GDB 跟踪方法调用堆栈环境的搭建                           :gdb:@编译:
   
   在 macOS 14.0 下使用 Vagrant + Ubuntu 16.04 + go 1.11
   
**** 安装必要命令行工具

     #+BEGIN_SRC sh
       # apt update
       # apt-get install gcc gdb binutils make python3-dbg git dstat sysstat htop curl wget upx tree
     #+END_SRC

     #+BEGIN_QUOTE
     这个安装必要工具可以放在 Vagrant 的配置文件里。
     #+END_QUOTE

**** 安装 Go

     #+BEGIN_SRC sh
       vagrant@trusty32:~$ wget https://dl.google.com/go/go1.11.1.linux-386.tar.gz
       vagrant@trusty32:~$ tar -zxvf go1.11.1.linux-386.tar.gz -C /usr/local
     #+END_SRC
    
**** 配置 Go 环境变量

     #+BEGIN_SRC sh
       vagrant@trusty32:~$ echo "export GOROOT=/usr/local/go" >> ~/.bashrc
       vagrant@trusty32:~$ echo "export GOBIN=/usr/local/go/bin" >> ~/.bashrc
       vagrant@trusty32:~$ echo "export PATH=/usr/local/go/bin:$PATH" >> ~/.bashrc
     #+END_SRC
**** 验证 Go 的配置

     #+BEGIN_SRC sh
       vagrant@trusty32:~$ source ~/.bashrc
       vagrant@trusty32:~$ go env
       GOARCH="386"
       GOBIN="/usr/local/go/bin"
       GOCACHE="/home/vagrant/.cache/go-build"
       GOEXE=""
       GOFLAGS=""
       GOHOSTARCH="386"
       GOHOSTOS="linux"
       GOOS="linux"
       GOPATH="/home/vagrant/go"
       GOPROXY=""
       GORACE=""
       GOROOT="/usr/local/go"
       GOTMPDIR=""
       GOTOOLDIR="/usr/local/go/pkg/tool/linux_386"
       GCCGO="gccgo"
       GO386="sse2"
       CC="gcc"
       CXX="g++"
       CGO_ENABLED="1"
       GOMOD=""
       CGO_CFLAGS="-g -O2"
       CGO_CPPFLAGS=""
       CGO_CXXFLAGS="-g -O2"
       CGO_FFLAGS="-g -O2"
       CGO_LDFLAGS="-g -O2"
       PKG_CONFIG="pkg-config"
       GOGCCFLAGS="-fPIC -m32 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build588680021=/tmp/go-build -gno-record-gcc-switches"
     #+END_SRC

**** 配置 Go workspace 目录

     #+BEGIN_SRC sh
     建立 Go 工作空间目录，完成后如下所示
     root@trusty64-135:/go# tree
     .
     ├── go.deps
     │   ├── bin
     │   ├── pkg
     │   └── src
     └── go.lesson
         ├── bin
         ├── pkg
         └── src
             └── function-call-stack
                 ├── Makefile
                 ├── test.c
                 └── test.go
     #+END_SRC

**** Vagrant 配置文件

     #+BEGIN_SRC ruby
       # -*- mode: ruby -*-
       # vi: set ft=ruby :

       Vagrant.configure("2") do |config|
         config.vm.hostname = "trusty32"
         config.vm.box = "ubuntu/trusty32"
         config.vm.synced_folder "./", "/vagrant_data"
         config.vm.provision "shell", inline: <<-SHELL
           apt-get update
           apt-get install -y gcc gdb binutils make python3-dbg git dstat sysstat htop curl wget upx tree
         SHELL
       end
     #+END_SRC

** DRAFT GDB 和 LLDB 查看函数调用栈                          :gdb:lldb:@编译:
*** 源文件

    C 源文件如下：

    #+BEGIN_SRC c -n
      #include <stdio.h>
      #include <stdlib.h>

      __attribute__((noinline)) void info(int x)
      {
          printf("info %d\n", x);
      }

      __attribute__((noinline)) int add(int x, int y)
      {
          int z = x + y;
          info(z);

          return z;
      }

      int main(int argc, char **argv)
      {
          int x = 0x100;
          int y = 0x200;
          int z = add(x, y);

          printf("%d\n", z);

          return 0;
      }
    #+END_SRC

    Go 源码如下:

    #+BEGIN_SRC go
      package main

      import "log"

      func info(x int) {
          log.Printf("info %d\n", x)
      }

      func add(x, y int) int {
          z := x + y
          info(z)

          return z
      }

      func main() {
          x, y := 0x100, 0x200
          z := add(x, y)

          println(z)
      }

    #+END_SRC

*** 说明

    本篇涵盖使用 GDB 查看函数调用栈帧，理解函数调用过程，并学习 GDB 相关指令

    Go 的符号和 C 的符号不一样，这个要注意下

*** C 语言示例
**** GDB 调试

     编译文件:

     #+BEGIN_SRC sh
    gcc -g -O0 -o test test.c # -O0 阻止编译器优化
     #+END_SRC

     使用 gdb 调试:

     #+BEGIN_SRC sh
      vagrant@trusty32:~/function-call-stack$ gdb ctest
      GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1
      Copyright (C) 2014 Free Software Foundation, Inc.
      License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
      This is free software: you are free to change and redistribute it.
      There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
      and "show warranty" for details.
      This GDB was configured as "i686-linux-gnu".
      Type "show configuration" for configuration details.
      For bug reporting instructions, please see:
      <http://www.gnu.org/software/gdb/bugs/>.
      Find the GDB manual and other documentation resources online at:
      <http://www.gnu.org/software/gdb/documentation/>.
      For help, type "help".
      Type "apropos word" to search for commands related to "word"...
      Reading symbols from ctest...done.
      (gdb) break main // 设置断点
      Breakpoint 1 at 0x8048462: file test.c, line 19.
      (gdb) break add // 设置断点
      Breakpoint 2 at 0x804843e: file test.c, line 11.
      (gdb) break info // 设置断点
      Breakpoint 3 at 0x8048423: file test.c, line 6.
      (gdb) info breakpoints // 查看所有断点
      Num     Type           Disp Enb Address    What
      1       breakpoint     keep y   0x08048462 in main at test.c:19
      2       breakpoint     keep y   0x0804843e in add at test.c:11
      3       breakpoint     keep y   0x08048423 in info at test.c:6
      (gdb) run // 执行当前程序
      Starting program: /home/vagrant/function-call-stack/ctest

      Breakpoint 1, main (argc=1, argv=0xbffff704) at test.c:19
      19		int x = 0x100;
      (gdb) backtrace // 查看函数调用栈
      #0  main (argc=1, argv=0xbffff704) at test.c:19
      (gdb) list main
      13
      14		return z;
      15	}
      16
      17	int main(int argc, char **argv)
      18	{
      19		int x = 0x100;
      20		int y = 0x200;
      21		int z = add(x, y);
      22
      (gdb) continue // 从当前位置继续执行程序，设置多个断点时使用
      Continuing.

      Breakpoint 2, add (x=256, y=512) at test.c:11
      11		int z = x + y;
      (gdb) backtrace
      #0  add (x=256, y=512) at test.c:11
      #1  0x08048486 in main (argc=1, argv=0xbffff704) at test.c:21
      (gdb) list add // 查看 main 函数源代码，main 为符号名
      5	{
      6		printf("info %d\n", x);
      7	}
      8
      9	__attribute__((noinline)) int add(int x, int y)
      10	{
      11		int z = x + y;
      12		info(z);
      13
      14		return z;
      (gdb) info frame // 查看当前栈帧
      Stack level 0, frame at 0xbffff640:
      eip = 0x804843e in add (test.c:11); saved eip = 0x8048486
      called by frame at 0xbffff670
      source language c.
      Arglist at 0xbffff638, args: x=256, y=512
      Locals at 0xbffff638, Previous frame's sp is 0xbffff640
      Saved registers:
        ebp at 0xbffff638, eip at 0xbffff63c
      (gdb) info args // 查看参数
      x = 256
      y = 512
      (gdb) info locals
      z = 134513341
      (gdb) frame 1 // 根据编号切换当前栈帧为 main
      #1  0x08048486 in main (argc=1, argv=0xbffff704) at test.c:21
      21		int z = add(x, y);
      (gdb) info frame
      Stack level 1, frame at 0xbffff670:
      eip = 0x8048486 in main (test.c:21); saved eip = 0xb7e3caf3
      caller of frame at 0xbffff640
      source language c.
      Arglist at 0xbffff668, args: argc=1, argv=0xbffff704
      Locals at 0xbffff668, Previous frame's sp is 0xbffff670
      Saved registers:
        ebp at 0xbffff668, eip at 0xbffff66c
      (gdb) down 1 // 当前是 main ，向下 1，就是 add
      #0  add (x=256, y=512) at test.c:11
      11		int z = x + y;
      (gdb) backtrace
      #0  add (x=256, y=512) at test.c:11
      #1  0x08048486 in main (argc=1, argv=0xbffff704) at test.c:21
      (gdb) up 1 // 当前是 add，向上 1 就是 main
      #1  0x08048486 in main (argc=1, argv=0xbffff704) at test.c:21
      21		int z = add(x, y);
      (gdb) backtrace
      #0  add (x=256, y=512) at test.c:11
      #1  0x08048486 in main (argc=1, argv=0xbffff704) at test.c:21
      (gdb) info proc mappings
      process 2990
      Mapped address spaces:

          Start Addr   End Addr       Size     Offset objfile
          0x8048000  0x8049000     0x1000        0x0 /home/vagrant/function-call-stack/ctest
          0x8049000  0x804a000     0x1000        0x0 /home/vagrant/function-call-stack/ctest
          0x804a000  0x804b000     0x1000     0x1000 /home/vagrant/function-call-stack/ctest
          0xb7e22000 0xb7e23000     0x1000        0x0
          0xb7e23000 0xb7fce000   0x1ab000        0x0 /lib/i386-linux-gnu/libc-2.19.so
          0xb7fce000 0xb7fd0000     0x2000   0x1aa000 /lib/i386-linux-gnu/libc-2.19.so
          0xb7fd0000 0xb7fd1000     0x1000   0x1ac000 /lib/i386-linux-gnu/libc-2.19.so
          0xb7fd1000 0xb7fd4000     0x3000        0x0
          0xb7fdc000 0xb7fdd000     0x1000        0x0
          0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]
          0xb7fde000 0xb7ffe000    0x20000        0x0 /lib/i386-linux-gnu/ld-2.19.so
          0xb7ffe000 0xb7fff000     0x1000    0x1f000 /lib/i386-linux-gnu/ld-2.19.so
          0xb7fff000 0xb8000000     0x1000    0x20000 /lib/i386-linux-gnu/ld-2.19.so
          0xbffdf000 0xc0000000    0x21000        0x0 [stack]
     #+END_SRC

**** LLDB 调试
*** Go 语言示例

    编译程序:

    #+BEGIN_SRC sh
    go build -gcflags "-N -l" -o gtest1 test.go # -N -l 编译器优化
    #+END_SRC

    查看 Go 提供的符号:

    #+BEGIN_SRC sh
      vagrant@trusty32:~/function-call-stack$ nm gtest | grep "main\."
      080c68f0 T main.add # add()
      080c6810 T main.info # info()
      080c69b0 T main.init
      08187546 B main.initdone.
      080c6940 T main.main # main()
      0808e0a0 T runtime.main.func1
      0808e0e0 T runtime.main.func2
    #+END_SRC

**** GDB 调试

     #+BEGIN_SRC sh
      vagrant@trusty32:~/function-call-stack$ gdb gtest
      GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1
      Copyright (C) 2014 Free Software Foundation, Inc.
      License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
      This is free software: you are free to change and redistribute it.
      There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
      and "show warranty" for details.
      This GDB was configured as "i686-linux-gnu".
      Type "show configuration" for configuration details.
      For bug reporting instructions, please see:
      <http://www.gnu.org/software/gdb/bugs/>.
      Find the GDB manual and other documentation resources online at:
      <http://www.gnu.org/software/gdb/documentation/>.
      For help, type "help".
      Type "apropos word" to search for commands related to "word"...
      Reading symbols from gtest...done.
      warning: File "/usr/local/go/src/runtime/runtime-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
      To enable execution of this file add
          add-auto-load-safe-path /usr/local/go/src/runtime/runtime-gdb.py
      line to your configuration file "/home/vagrant/.gdbinit".
      To completely disable this security protection add
          set auto-load safe-path /
      line to your configuration file "/home/vagrant/.gdbinit".
      For more information about this security protection see the
      "Auto-loading safe path" section in the GDB manual.  E.g., run from the shell:
          info "(gdb)Auto-loading safe path"
      (gdb) b main.main // 根据符号设置断点
      Breakpoint 1 at 0x80c6940: file /home/vagrant/function-call-stack/test.go, line 16.
      (gdb) b main.add // 根据符号设置断点
      Breakpoint 2 at 0x80c68f0: file /home/vagrant/function-call-stack/test.go, line 9.
      (gdb) b main.info // 根据符号设置断点
      Breakpoint 3 at 0x80c6810: file /home/vagrant/function-call-stack/test.go, line 5.
      (gdb) info b // 查看所有断点
      Num     Type           Disp Enb Address    What
      1       breakpoint     keep y   0x080c6940 in main.main at /home/vagrant/function-call-stack/test.go:16
      2       breakpoint     keep y   0x080c68f0 in main.add at /home/vagrant/function-call-stack/test.go:9
      3       breakpoint     keep y   0x080c6810 in main.info at /home/vagrant/function-call-stack/test.go:5
      (gdb) l // 执行程序
      7	}
      8
      9	func add(x, y int) int {
      10		z := x + y
      11		info(z)
      12
      13		return z
      14	}
      15
      16	func main() {
      (gdb) l
      17		x, y := 0x100, 0x200
      18		z := add(x, y)
      19
      20		println(z)
      21	}
      (gdb) r // 执行程序
      Starting program: /home/vagrant/function-call-stack/gtest

      Breakpoint 1, main.main () at /home/vagrant/function-call-stack/test.go:16
      16	func main() {
      (gdb) bt // 查看调用堆栈
      #0  main.main () at /home/vagrant/function-call-stack/test.go:16
      (gdb) c
      Continuing.

      Breakpoint 2, main.add (x=256, y=512, ~r2=0) at /home/vagrant/function-call-stack/test.go:9
      9	func add(x, y int) int {
      (gdb) bt
      #0  main.add (x=256, y=512, ~r2=0) at /home/vagrant/function-call-stack/test.go:9
      #1  0x080c6979 in main.main () at /home/vagrant/function-call-stack/test.go:18
      (gdb) c
      Continuing.

      Breakpoint 3, main.info (x=768) at /home/vagrant/function-call-stack/test.go:5
      5	func info(x int) {
      (gdb) bt
      #0  main.info (x=768) at /home/vagrant/function-call-stack/test.go:5
      #1  0x080c6921 in main.add (x=256, y=512, ~r2=0) at /home/vagrant/function-call-stack/test.go:11
      #2  0x080c6979 in main.main () at /home/vagrant/function-call-stack/test.go:18
      (gdb) info proc mappings
      process 3189
      Mapped address spaces:

          Start Addr   End Addr       Size     Offset objfile
          0x8048000  0x80c7000    0x7f000        0x0 /home/vagrant/function-call-stack/gtest
          0x80c7000  0x8166000    0x9f000    0x7f000 /home/vagrant/function-call-stack/gtest
          0x8166000  0x8176000    0x10000   0x11e000 /home/vagrant/function-call-stack/gtest
          0x8176000  0x818a000    0x14000        0x0 [heap]
          0x8400000  0x8800000   0x400000        0x0 [stack:3189]
          0x8800000 0x28800000 0x20000000        0x0
          0xa7d5f000 0xa7e00000    0xa1000        0x0
          0xa7e00000 0xb7fbf000 0x101bf000        0x0
          0xb7fbf000 0xb7fff000    0x40000        0x0
          0xb7fff000 0xb8000000     0x1000        0x0 [vdso]
          0xbffdf000 0xc0000000    0x21000        0x0
      (gdb) quit
     #+END_SRC
    
**** LLDB 调试

     #+BEGIN_SRC sh
     
     #+END_SRC
*** 参考书籍

    - 《Go 学习笔记》雨痕
    - 《C 学习笔记》雨痕
    - 《程序员的自我修养-链接，装载，库》

** DRAFT GDB 和 LLDB 跟踪 C 语言函数执行过程

   https://favoorr.github.io/2017/02/26/gdb-trace-c-function-call/

*** 总结

    - C 语言中函数调用时会分配对应的栈帧，rsp 始终指向栈帧顶部，rbp 指向栈帧底部
    - C 语言中使用 (rbp - 偏移量) 来进行栈帧寻址操作，完成函数调用
    - C 语言中函数调用时，会使用寄存器来进行值复制传递
    - C 语言中现场保护时会保存 rbp 和 rip，下一级函数调用结束后，恢复值，继续执行

** DRAFT GDB 和 LLDB 跟踪 Go 语言方法执行过程 
*** 总结
    - Go 语言中函数调用时会分配对应的栈帧，rsp 始终指向栈帧顶部，rbp 被当做普通寄存器使用
    - Go 语言中使用 (rsp + 偏移量) 来进行栈帧寻址操作，完成函数调用
    - Go 语言中函数调用时，会在栈上开辟空间，完成值复制传递
    - Go 语言中现场保护时会保存 rip，下一级函数调用结束后，恢复值，继续执行
    - Go 语言中指针宽度是 8 个字节

      可以观察到 Go 语言根据自己语言特性和定位，实现方式并不跟 C 语言完全相同， 例如多返回值，使用栈上存储就非常方便

      https://favoorr.github.io/2017/02/26/gdb-trace-go-function-call/
** DRAFT CMake 入门 
   https://app.yinxiang.com/shard/s18/nl/19217884/bc747114-12c1-44d0-9a40-b7d3cadcea93/
** TODO core dump 的使用
   https://app.yinxiang.com/shard/s18/nl/19217884/7cd508ca-ec42-4b2e-bb55-b2890cc0b8b4/
* Vagrant
** DRAFT Vagrant 的配置和使用
** DRAFT Vagrant 的配置集群
   https://favoorr.github.io/2017/01/06/vagrant-multiple-servers-cluster-config-best-practices/
* Language
** C and Cplusplus
** Golang
*** DRAFT Golang 学习之 Channel 深入
*** DRAFT Golang 调用 C/C++
    https://app.yinxiang.com/shard/s18/nl/19217884/f289fb4d-8656-4c6b-9dbc-e211b804d70d/
** Java
*** DRAFT Java 入门

**** 0x00 环境变量配置

     使用的命令

     #+BEGIN_SRC sh
      javac
      java
     #+END_SRC

     第一个程序

     #+BEGIN_SRC java
      // filename: HelloWorld.java
      public class HelloWorld {
          public static void main(String[] args) {
              System.out.println("Hello World!");
          }
      }
     #+END_SRC

     #+BEGIN_SRC sh
      # 编译
      javac javac HelloWorld.java

      # 运行
      java HelloWorld
     #+END_SRC

**** Java 资料

     - http://ifeve.com/
     - https://javacodegeeks.com

** Python
* Network
** DNS
** TCP
** UDP
** Shadowsock
   - Sock5
   - PAC
* Editor and IDE
** Emacs
*** Emacsclient 和 Emacs daemon
*** DRAFT 在Org-mode中执行代码

    https://brantou.github.io//2017/06/12/go-source-code-block-in-org/

**** 在Org-mode中执行 C 代码
**** 在Org-mode中执行 Go 代码
**** 在Org-mode中执行 Python 代码
*** DRAFT 在Org-mode中计算表格
** Vim
** VSCode
*** DRAFT VSCode 的命令行使用

**** 参考
     - https://code.visualstudio.com/docs/editor/command-line
* 源码分析
** 学习 Redis 源码
** 学习 Nginx 源码
** 学习 Libevent 源码
** 学习 Memcached 源码
** 学习 Tornado 源码
* Other
** DRAFT 关于工具                                                     :@想法:

   人们都是对于自己付出了努力的东西特人珍视，哪怕这个东西不是最好的，他们也不会轻易放弃。
   我最近就有这个想法，自己一直以来一直想要学习 Emacs， 因此付出了很多的努力，所以哪怕当 Emacs 出现卡死或者其他很难就觉得问题，我还是会继续忍受下去，因为我付出了努力。
** DRAFT 关于 ARTS

   ARTS 是指：

   - Algorithm 一道算法题
   - Review 读一篇英文文章
   - Technique/Tips 分享一个小技术
   - Share 分享一个观点

** DRAFT 使用 hugo 和 ox-hugo 搭建自己的 BLOG            :emacs:orgmode:hugo:
   :PROPERTIES:
   :EXPORT_FILE_NAME: use-orgmode-and-hugo-write-blog
   :EXPORT_DATE: <2018-10-16 Tue>
   :END:

   - 为什么要写这个文章？
   - 为什么使用 hugo 而不是 hexo 或者其他的？
     > hexo node 写的，环境配置等麻烦
   - 为什么使用 org-mode , 而不是 markdown, 明明 Markdown 更有名

*** 缘起

    =org-mode= 是一个很强的纯文本语法格式，自己非常喜欢 =org-mode= ，因此自己使用 =org-mode= 来记录自己的笔记。当自己要开始写 BLOG 的时候，就决定决定使用 =org-mode= 来作为自己 BLOG 管理工具，之前是使用 emacs 的插件 [[https://github.com/CodeFalling/blog-admin][blog-admin]] 和 [[https://hexo.io/][hexo]] 生成自己的 BLOG，但是自己不是很喜欢这种组合 [[https://github.com/CodeFalling/blog-admin][blog-admin]] 。有两个原因：一个是 [[https://github.com/CodeFalling/blog-admin][blog-admin]] 已经不怎么更新了，还有一个就是自己不怎么喜欢 [[https://hexo.io/][hexo]] (我自己不怎么喜欢node)。

    <!--more-->

    因此我就选择了以下的组合:

    - [[https://gohugo.io/][hugo]] : 使用 Golang 开发的静态 BLOG 工具
    - [[https://ox-hugo.scripter.co/][ox-hugo]] : 用于把 =*.org= 转为 hugo 可以识别的 =*.md=
    - [[https://github.com/masasam/emacs-easy-hugo][easy-hugo]]
    - 当然还少不了 [[https://orgmode.org/][orgmode]]

    使用上面说的工具的组合，那么写一篇 BLOG 的变为如下：

    1. 使用 org-mode heading 创建文章
    2. 写文章
    3. 使用 ox-hugo 生成 markdown 文档
    4. 使用 easy-hugo 预览(可选)
    5. 发布 BLOG


    这里使用到了两个工具：ox-hugo 和 easy-hugo, 接下就介绍这两个工具。

    #+BEGIN_QUOTE
    其实 hugo 原生支持渲染 orgmode 文件，但是它所使用的 markdown 渲染引擎比 orgmode 的渲染引擎要强大的多，这是使用 ox-hugo 的原因之一。
    #+END_QUOTE

*** ox-hugo: org 为 markdown

    [[https://ox-hugo.scripter.co/][ox-hugo]] 可以将 org 文件转成 hugo 兼容的 markdown 文件, 也可生成前端格式文件（如 toml 和 yaml）。

    可以将你的 orgmode 博文，生成指定的 markdown 文件，这只需要一条指令就够了（官方默认 =C-c C-e H h=），并且，它还会自动更正你的文章修改时间 ，markdown 文件中的 lastmod 值。但让也可以自动生成相应的 markdonw 文件，不用每次都执行 =C-c C-e H h=

    至此，你就已经可以按照常规的方法来预览、发布你的博文了。不过还有一个扩展没有介绍—— easy-hugo 。

    #+BEGIN_QUOTE
    导出的 markdown 文件会编译不过，原因是因为生成的 =author= 标签， =hugo= 报错。因此可以把这个 =author= 禁止掉就可以了 ( =#+options: author:nil= )。
    #+END_QUOTE

**** 入门
***** ScreenShot

      ox-hugo 提供了两种工作流来写 BLOG

      方法1:
      [[file:use-orgmode-and-hugo-write-blog/one-post-per-subtree.png]]

      方法2:
      [[file:use-orgmode-and-hugo-write-blog/one-post-per-file.png]]

***** 安装

      需要 emacs 24.4+ 和 Org 9.0+

***** 配置

      =spacemacs= 中 =ox-hugo= 的配置, 在 =dotspacemacs/user-config= 中添加配置：

      #+BEGIN_SRC emacs-lisp
      (defun dotspacemacs/user-config ()
        ;; Other stuff
        ;; ..

        ;; ox-hugo config
        (use-package ox-hugo
          :ensure t            ;Auto-install the package from Melpa (optional)
          :after ox)
        (use-package ox-hugo-auto-export) ;If you want the auto-exporting on file saves
        (use-package ox-hugo
          :ensure t            ;Auto-install the package from Melpa (optional)
          :after ox)
        (use-package ox-hugo-auto-export) ;If you want the auto-exporting on file saves
        )
      #+END_SRC

      其他的配置参考 [[https://ox-hugo.scripter.co/][ox-hugo]] 官方文档。

**** Org To Hugo
***** 基于单个文件的导出

      #+caption: Hugo front-matter translation for subtree-based exports
      | Hugo front-matter (TOML)	     | Org                                  |
      |----------------------------------+--------------------------------------|
      | title = "foo"	                | =#+title: foo=                       |
      | date = 2017-07-24                | =#+date: 2017-07-24=                 |
      | publishDate = 2018-01-26	     | =#+hugo_publishdate: 2018-01-26=     |
      | expiryDate = 2999-01-01	      | =#+hugo_expirydate: 2999-01-01=      |
      | lastmod = <current date>	     | =#+hugo_auto_set_lastmod: t=         |
      | tags = ["toto", "zulu"]	      | =#+hugo_tags: toto zulu=             |
      | categories = ["x", "y"]	      | =#+hugo_categories: x y=             |
      | draft = true	                 | =#+hugo_draft: true=                 |
      | draft = false	                | =#+hugo_draft: false=                |
      | weight = 123	                 | =#+hugo_weight: 123=                 |
      | tags_weight = 123	            | =#+hugo_weight: :tags 123=           |
      | categories_weight = 123          | =#+hugo_weight: :categories 123=     |
      | weight = 123 (in [menu.foo])	 | =#+hugo_menu: :menu foo :weight 123= |

***** 格式化

      下表是 orgmode 标记语言转换 markdown 标记语言的格式:

      #+caption: Org markup to Markdown markup
      | Org	             | Markdown                                                       |
      |---------------------+----------------------------------------------------------------|
      | =*bold*=	        |  =**bold**=                                                    |
      | =/italics/=	     | =_italics_=                                                    |
      | =\=monospace\==     | 	=`monospace`=                                              |
      | =~key-binding~=	 | =`key-binding`=                                                |
      |                     | - if org-hugo-use-code-for-kbd is nil [default]                |
      | =~key-binding~=	 | =<kbd>key-binding</kbd>=                                       |
      |                     | - if org-hugo-use-code-for-kbd is non-nil                      |
      |                     | - Requires CSS to render the <kbd> tag as something special.   |
      | =+strike-through+=  | 	~~strike-through~~                                         |
      | =_underline_=	   | =<span class = "underline">underline</span>=                   |
      |                     | - Requires CSS to render this underline class as an underline. |

**** 进阶
***** 自动生成 markdown 文件配置

      在 =hugo= 的 =base= 目录下新建一个目录 =content-org=，并且新建文件 =.dir-locals.el=, 内容如下：

      #+BEGIN_SRC emacs-lisp
      (("content-org/"
        . ((org-mode . ((org-hugo-auto-export-on-save . t))))))
      #+END_SRC

      新建目录和文件后的目录结构如下：

      #+BEGIN_EXAMPLE
      <HUGO_BASE_DIR>
        ├── config.toml
        ├── content
        ├── content-org      <-- Org 文件写到这个目录
        ├── static
        ├── themes
        └── .dir-locals.el
      #+END_EXAMPLE

      还没有完，需要在每个 =org= 文件后添加如下内容，这样会很麻烦，但是我们可以使用 =yassnnpets= 来完成：

***** Org 文件中包含图片

      把图片放到 org 文件目录下，使用如下语法就可以引用图片:

      #+BEGIN_EXAMPLE
      [[file:image_path]]
      #+END_EXAMPLE

*** 附录
**** 我的Snipptes

     #+BEGIN_EXAMPLE
     # -*- mode: snippet -*-
     # name: hugo
     # key: hugo
     # --
     #+HUGO_BASE_DIR: ~/blog
     #+HUGO_SECTION: ./post
     #+TITLE: $1
     #+DATE: `(format-time-string "%Y-%m-%d")`
     #+options: author:nil
     #+HUGO_AUTO_SET_LASTMOD: t
     #+HUGO_TAGS: $2
     #+HUGO_CATEGORIES: $3
     #+HUGO_DRAFT: false

     $0

     * Footnotes
     * COMMENT Local Variables                          :ARCHIVE:
     # Local Variables:
     # org-hugo-auto-export-on-save: t
     # End:
     #+END_EXAMPLE

*** 参考

    - [[https://ox-hugo.scripter.co/]]
    - [[https://github.com/masasam/emacs-easy-hugo]]
    - [[http://www.xianmin.org/post/ox-hugo/]]
    - [[https://blog.coderzh.com/2015/08/29/hugo/]]
      
** DRAFT 从源码到可执行文件-编译-链接-执行

   https://favoorr.github.io/2017/03/01/compile-link-1/

** TODO RPCX 入门
*** 介绍
*** 安装
*** 用法
*** 资料

    - http://rpcx.site/
    - https://doc.rpcx.site/
    - [[https://en.wikipedia.org/wiki/RPC][RPC Wiki]]
    - [[https://www.gitbook.com/book/smallnest/go-rpc][Go RPC 开发指南]]

** TODO 编码
   https://app.yinxiang.com/shard/s18/nl/19217884/55e95f2b-5d41-4540-a6e3-a97288aab99a/
* Footnotes
* COMMENT Local Variables                          :ARCHIVE:
  # Local Variables:
  # org-hugo-auto-export-on-save: nil
  # End:

